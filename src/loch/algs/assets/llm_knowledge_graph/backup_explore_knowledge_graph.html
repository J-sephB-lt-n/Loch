<!-- This code entirely written by ChatGPT 4o-mini-high - still needs thorough review -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Knowledge Graph Force-Directed Plot</title>
  <style>
    body { margin: 0; font-family: Arial, sans-serif; }
    svg { width: 100vw; height: 100vh; background-color: #f9f9f9; }
    .links line { stroke: #999; stroke-opacity: 0.6; }
    .nodes circle { stroke: #fff; stroke-width: 1.5px; }
    .edge-label { pointer-events: none; font-size: 10px; fill: #555; }
    #tooltip {
      position: absolute;
      visibility: hidden;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 12px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      pointer-events: none;
      max-width: 200px;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <svg></svg>
  <div id="tooltip"></div>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
  (function() {
    'use strict';

    const jsonURL = `${window.location.origin}/knowledge_graph_data.json`;
    const svg = d3.select('svg');
    const width = window.innerWidth, height = window.innerHeight;
    const tooltip = d3.select('#tooltip');

    fetch(jsonURL)
      .then(res => res.json())
      .then(data => {
        const nodes = data.nodes;
        // NetworkX wrote your edges under "edges"â€”but fall back to "links" if present
        const links = data.edges ?? data.links;
        if (!Array.isArray(links)) {
          throw new Error('Graph JSON has no iterable links/edges array');
        }

        const simulation = d3.forceSimulation(nodes)
          .force('link', d3.forceLink(links)
                           .id(d => d.id)
                           .distance(100)
                           .strength(1))
          .force('charge', d3.forceManyBody().strength(-300))
          .force('center', d3.forceCenter(width / 2, height / 2))
          .force('collide', d3.forceCollide(20));

        // --- LINKS ---
        const link = svg.append('g')
          .attr('class', 'links')
          .selectAll('line')
          .data(links)
          .enter().append('line');

        // --- EDGE LABELS ---
        const edgeLabels = svg.append('g')
          .attr('class', 'edge-labels')
          .selectAll('text')
          .data(links)
          .enter().append('text')
            .attr('class', 'edge-label')
            .text(d => d.label || '');

        // --- NODES ---
        const node = svg.append('g')
          .attr('class', 'nodes')
          .selectAll('g')
          .data(nodes)
          .enter().append('g')
            .call(d3.drag()
              .on('start', dragstarted)
              .on('drag', dragged)
              .on('end', dragended)
            );

        node.append('circle')
          .attr('r', 10)
          .attr('fill', '#69b3a2');

        node.append('text')
          .attr('dy', -15)
          .attr('text-anchor', 'middle')
          .attr('font-size', '10px')
          .text(d => d.id);

        // TOOLTIP
        node.on('mouseover', (event, d) => {
            const attrs = { ...d };
            delete attrs.id;
            const html = Object.entries(attrs)
              .map(([k, v]) => `<strong>${k}:</strong> ${v}`)
              .join('<br>');
            tooltip.html(html)
                   .style('visibility', 'visible');
          })
          .on('mousemove', event => {
            tooltip
              .style('top', (event.pageY + 12) + 'px')
              .style('left', (event.pageX + 12) + 'px');
          })
          .on('mouseout', () => {
            tooltip.style('visibility', 'hidden');
          });

        // SIMULATION TICK
        simulation.on('tick', () => {
          link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);

          edgeLabels
            .attr('x', d => (d.source.x + d.target.x) / 2)
            .attr('y', d => (d.source.y + d.target.y) / 2);

          node.attr('transform', d => `translate(${d.x},${d.y})`);
        });

        // DRAG HANDLERS
        function dragstarted(event, d) {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x; d.fy = d.y;
        }
        function dragged(event, d) {
          d.fx = event.x; d.fy = event.y;
        }
        function dragended(event, d) {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null; d.fy = null;
        }

      })
      .catch(err => {
        console.error('Error loading or parsing graph data:', err);
      });

  })();
  </script>
</body>
</html>

