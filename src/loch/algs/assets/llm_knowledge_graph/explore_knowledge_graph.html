<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Knowledge-Graph Viewer</title>
<style>
    body      { margin:0; font-family: system-ui, sans-serif; }
    svg       { width:100vw; height:100vh; display:block; }
    .link     { stroke:#999; stroke-width:1.5px; }
    .linkText { font-size: 10px; fill:#555; pointer-events:none; }
    .nodeText { font-size: 12px; fill:#000; pointer-events:none; }
    .tooltip  {
        position: absolute; padding:6px 9px; border-radius:4px;
        background:#333; color:#fff; font-size:12px; pointer-events:none;
        opacity:0; transition: opacity .2s;
    }
</style>
</head>
<body>
<svg></svg>
<div id="tooltip" class="tooltip"></div>

<!-- D3 v7 (latest stable) -->
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
(async () => {
  /* ---------- CONFIG ---------- */
  const jsonURL = `${window.location.origin}/knowledge_graph_data.json`;
  const arrowColor = "#999";
  const nodeRadius = 8;

  /* ---------- FETCH + NORMALISE ---------- */
  const data   = await fetch(jsonURL).then(r => r.json());
  const nodes  = data.nodes || data;                                  // fallback if top-level is nodes array
  const links  = data.links || data.edges || [];                      // supports NetworkX “links” or custom “edges”

  /* ---------- SVG + DEFS ---------- */
  const svg   = d3.select("svg");
  const defs  = svg.append("defs");

  // Arrowhead marker
  defs.append("marker")
      .attr("id", "arrow")
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 15)   // adjust relative to nodeRadius
      .attr("refY", 0)
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M0,-5L10,0L0,5")
      .attr("fill", arrowColor);

  /* ---------- FORCE SIMULATION ---------- */
  const sim = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d => d.id ?? d.name).distance(120))
    .force("charge", d3.forceManyBody().strength(-400))
    .force("center", d3.forceCenter(window.innerWidth/2, window.innerHeight/2))
    .force("collision", d3.forceCollide(nodeRadius*2.2));

  /* ---------- EDGES ---------- */
  const link = svg.append("g")
      .attr("stroke", arrowColor)
      .attr("stroke-opacity", 0.7)
    .selectAll("line")
    .data(links)
    .join("line")
      .attr("class", "link")
      .attr("marker-end", "url(#arrow)");

  /* Edge labels */
  const linkText = svg.append("g")
      .selectAll("text")
      .data(links)
      .join("text")
      .attr("class", "linkText")
      .attr("dy", -4)
      .text(d => d.relationship ?? "");

  /* ---------- NODES ---------- */
  const node = svg.append("g")
      .selectAll("circle")
      .data(nodes)
      .join("circle")
      .attr("r", nodeRadius)
      .attr("fill", "#1f77b4")
      .call(drag(sim));

  /* Node labels */
  const nodeText = svg.append("g")
      .selectAll("text")
      .data(nodes)
      .join("text")
      .attr("class", "nodeText")
      .attr("dy", -12)
      .attr("text-anchor", "middle")
      .text(d => d.name ?? d.id);

  /* ---------- TOOLTIP ---------- */
  const tooltip = d3.select("#tooltip");

  node.on("mouseover", (e, d) => {
        tooltip.style("opacity", 1)
               .html(formatAttributes(d));
      })
      .on("mousemove", (e) => {
        tooltip.style("left", (e.pageX + 10) + "px")
               .style("top",  (e.pageY + 10) + "px");
      })
      .on("mouseout", () => tooltip.style("opacity", 0));

  function formatAttributes(d) {
    return Object.entries(d)
      .map(([k,v]) => `<b>${k}</b>: ${v}`)
      .join("<br>");
  }

  /* ---------- TICK UPDATE ---------- */
  sim.on("tick", () => {
      link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

      node
          .attr("cx", d => d.x)
          .attr("cy", d => d.y);

      nodeText
          .attr("x", d => d.x)
          .attr("y", d => d.y);

      linkText
          .attr("x", d => (d.source.x + d.target.x) / 2)
          .attr("y", d => (d.source.y + d.target.y) / 2);
  });

  /* ---------- DRAG SUPPORT ---------- */
  function drag(sim) {
    return d3.drag()
      .on("start", (event, d) => {
        if (!event.active) sim.alphaTarget(0.3).restart();
        d.fx = d.x; d.fy = d.y;
      })
      .on("drag", (event, d) => {
        d.fx = event.x; d.fy = event.y;
      })
      .on("end", (event, d) => {
        if (!event.active) sim.alphaTarget(0);
        d.fx = null; d.fy = null;
      });
  }

  /* ---------- RESIZE ---------- */
  window.addEventListener("resize", () => {
    svg.attr("width", window.innerWidth)
       .attr("height", window.innerHeight);
    sim.force("center", d3.forceCenter(window.innerWidth/2, window.innerHeight/2));
    sim.alpha(0.3).restart();
  });
})();
</script>
</body>
</html>

